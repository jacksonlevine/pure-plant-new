---
import ProductLayouts from "@/functional-components/product/ProductLayouts";
import ProductFilters from "@/functional-components/ProductFilters";
import ProductLayoutViews from "@/functional-components/ProductLayoutViews";
import { defaultSort, sorting } from "@/lib/constants";
import {
    getCollectionProducts,
    getCollections,
    getProducts
} from "@/lib/shopify";
import type { PageInfo, Product } from "@/lib/shopify/types";

import {
    getProductAggregateRating,
    getProductReviewStructuredData,
} from "@/lib/reviews";


import Layout from "../../../layouts/Layout.astro";
import { getLocaleStaticPaths, localizedPath, localizedSiteUrl, resolveLocaleFromParams } from "../../../lib/i18n/paths";
import type { LocaleCode } from "../../../lib/i18n/config";

export const prerender = true;
export function getStaticPaths() {
    return getLocaleStaticPaths();
}

const locale = resolveLocaleFromParams(Astro.params) as LocaleCode;

const searchParams = Astro.url.searchParams;
const searchParamsObject = Object.fromEntries(searchParams.entries());

const sort = searchParamsObject.sort || "";
const searchValue = searchParamsObject.q || "";
const minPrice = searchParamsObject.minPrice || "";
const maxPrice = searchParamsObject.maxPrice || "";
const brand = searchParamsObject.b || "";
const category = searchParamsObject.c || "all";
const tag = searchParamsObject.t || "";
const cursor = searchParamsObject.cursor || null;

const { sortKey, reverse } =
sorting.find((item) => item.slug === sort) || defaultSort;

let productsData: any;
let categoriesWithCounts: { category: string; productCount: number }[] = [];

if (searchValue || brand || minPrice || maxPrice || category || tag) {
    let queryString = "";

    if (minPrice || maxPrice) {
        queryString += `variants.price:<=${maxPrice} variants.price:>=${minPrice}`;
    }

    if (searchValue) {
        queryString += ` ${searchValue}`;
    }

    if (brand) {
        Array.isArray(brand)
            ? (queryString += `${brand.map((b) => `(vendor:${b})`).join(" OR ")}`)
            : (queryString += `vendor:"${brand}"`);
    }

    if (tag) {
        queryString += ` ${tag}`;
    }

    const query = {
        sortKey,
        reverse,
        query: queryString,
        cursor: cursor || undefined,
    };

    try {
        productsData =
            category && category !== "all"
                ? await getCollectionProducts({
                    collection: category,
                    sortKey,
                    reverse,
                })
                : await getProducts(query);
    } catch (error) {
        console.error("Error fetching products:", error);
        productsData = { products: [] };
    }

    const uniqueVendors: string[] = [
        ...new Set(
            ((productsData?.products as Product[]) || []).map((product: Product) =>
                String(product?.vendor || "")
            )
        ),
    ];

    const uniqueCategories: string[] = [
        ...new Set(
            ((productsData?.products as Product[]) || []).flatMap(
                (product: Product) =>
                    product.collections.nodes.map(
                        (collectionNode: any) => collectionNode.title || ""
                    )
            )
        ),
    ];

    categoriesWithCounts = uniqueCategories.map((category: string) => {
        const productCount = ((productsData?.products as Product[]) || []).filter(
            (product: Product) =>
                product.collections.nodes.some(
                    (collectionNode: any) => collectionNode.title === category
                )
        ).length;
        return { category, productCount };
    });
} else {
    // Fetch all products
    try {
        productsData = await getProducts({
            sortKey,
            reverse,
            cursor: cursor || undefined,
        });
    } catch (error) {
        console.error("Error fetching products:", error);
        productsData = { products: [] };
    }
}

const categories = await getCollections();

const tags = [
    ...new Set(
        (
            productsData as { pageInfo: PageInfo; products: Product[] }
        )?.products.flatMap((product: Product) => product.tags)
    ),
];

const initialProducts = productsData.products;
const initialPageInfo = productsData.pageInfo;

//JSON LD stuff

const siteBase = localizedSiteUrl(Astro, locale, '/');
const canonicalUrl = new URL(Astro.url.pathname, Astro.site).toString();

const catalogProducts = (initialProducts || []).map((product: Product, index: number) => {
    const aggregateRating = getProductAggregateRating(product.handle);
    const reviews = getProductReviewStructuredData(product.handle);
    const productUrl = localizedSiteUrl(Astro, locale, `/products/${product.handle}`);
    const productId = `${productUrl}#product`;

    return {
        listItem: {
            "@type": "ListItem",
            position: index + 1,
            name: product.title,
            item: {
                "@type": "Product",
                "@id": productId,
            },
        },
        node: {
            "@type": "Product",
            "@id": productId,
            name: product.title,
            description: product.description,
            brand: {
                "@type": "Brand",
                name: product.vendor || "Pure Plant",
            },
            sku: product?.variants?.[0]?.id,
            url: productUrl,
            offers: {
                "@type": "AggregateOffer",
                priceCurrency: product.priceRange?.minVariantPrice?.currencyCode,
                lowPrice: product.priceRange?.minVariantPrice?.amount,
                highPrice: product.priceRange?.maxVariantPrice?.amount,
                availability: product.availableForSale
                    ? "https://schema.org/InStock"
                    : "https://schema.org/OutOfStock",
            },
            ...(aggregateRating ? { aggregateRating } : {}),
            ...(reviews.length ? { review: reviews } : {}),
        },
    };
});

const itemListElements = catalogProducts.map((product) => product.listItem);
const catalogProductNodes = catalogProducts.map((product) => product.node);

const productsStructuredData = [
    {
        "@type": "CollectionPage",
        "@id": `${canonicalUrl}#collection`,
        url: canonicalUrl,
        name: "Pure Plant Supplement Catalog",
        description:
            "Browse Pure Plant's full line of precision-formulated supplements for mood, cognition, and immune support.",
        inLanguage: "en",
        isPartOf: {
            "@id": `${siteBase}/#website`,
        },
    },
    {
        "@type": "ItemList",
        "@id": `${canonicalUrl}#product-grid`,
        name: "Pure Plant Supplements",
        numberOfItems: itemListElements.length,
        itemListOrder: "https://schema.org/ItemListOrderAscending",
        itemListElement: itemListElements,
    },
    ...catalogProductNodes,
];


---

<Layout
        title="Pure Plant Supplements Catalog"
        description="Shop Pure Plant's full collection of supplements including Serophan, Neurozine, and PurePlant D3."
        structuredData={productsStructuredData}
>
    <div class="h-[12rem] lg:h-[6rem]"></div>
    <ProductLayouts
            categories={categories}
            tags={tags}
            categoriesWithCounts={categoriesWithCounts}
            client:only="react"
    />

    <div class="container">
        <div class="row">
            <div class="col-3 hidden lg:block -mt-14">
                <ProductFilters
                        categories={categories}
                        tags={tags}
                        categoriesWithCounts={categoriesWithCounts}
                        client:only="react"
                />
            </div>

            <ProductLayoutViews
                    initialProducts={initialProducts}
                    initialPageInfo={initialPageInfo}
                    sortKey={sortKey}
                    reverse={reverse}
                    searchValue={searchValue}
                    client:only="react"
            />
            <!--<CallToAction />-->
        </div>
    </div>
</Layout>